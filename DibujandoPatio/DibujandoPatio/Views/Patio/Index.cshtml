
@{
    ViewBag.Title = "Dibujando Patio";
}


<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Editor de patios</title>

    <script src="https://cdn.jsdelivr.net/npm/konva@9.0.0/konva.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>


    <style>
        body {
            font-family: Arial;
        }

        #container {
            width: 1200px;
            height: 800px;
            border: 1px solid black;
            margin-top: 10px;
        }
    </style>

</head>
<body>
    <h2>Dibujar Patios</h2>
    <input type="text" id="nombreInput" placeholder="Ingresa el nombre del patio" />
    <br />
    <br />
    <label for="escalaInput">Escala:</label>
    <input type="number" id="escalaInput" value="0.5" step="0.1" min="0.1" />
    <br />
    <br />
    <button id="crearPatioBtn">Iniciar Dibujo</button>
    <button id="guardarBtn" disabled>Guardar</button>
    <select id="selectPatio">
        <option value="">Selecciona un patio</option>
    </select>

    <div id="container"></div>

    <script>

        var Lienzo = {
            lstPunto: [],
            PuntoActual: null,
            Cerrar: function () {
                var puntoInicial = this.lstPunto[0];
                var puntoFinal = this.lstPunto[this.lstPunto.length - 2];

                var linea = new Linea(puntoInicial, puntoFinal);

                puntoInicial.lstRelacionado.push(linea);
                puntoFinal.lstRelacionado.push(linea);

                puntoInicial.Dibujar();
                puntoFinal.Dibujar();
                this.PuntoActual = null;
            },
            AgregarPunto: function (x, y) {
                var punto = new Punto();
                punto.Posicion.x = x;
                punto.Posicion.y = y;

                this.lstPunto.push(punto);

                if (this.PuntoActual != null) {
                    var linea = new Linea(this.PuntoActual, punto);
                    this.PuntoActual.lstRelacionado.push(punto);
                    punto.lstRelacionado.push(linea);
                }
                punto.Dibujar();
                this.PuntoActual = punto;
            },
            HabilitarArrastrable: function (habilitar) {
                if (habilitar) {
                    this.Stage.draggable(true);
                    this.Stage.startDrag();
                    this._contextualMenuHandler = (e) => e.preventDefault();
                    this.Stage.container().addEventListener('contextmenu', this._contextualMenuHandler);
                } else {
                    this.Stage.draggable(false);
                    //if (this._contextualMenuHandler) {
                        this.Stage.container().removeEventListener('contextmenu', this._contextualMenuHandler);
                        //this._contextualMenuHandler = null;
                    //}
                }
            }
        };

        var enumTipoGrafico = {
            Linea: 'Linea',
            Punto: 'Punto'
        };

        function Linea(puntoInicial, puntoFinal) {
            this.Tipo = enumTipoGrafico.Linea;
            this.Grafico = null;
            this.GraficoTexto = null;
            this.lstRelacionado = [];

            this.PuntoInicial = puntoInicial
            this.PuntoFinal = puntoFinal;

            this.Eliminar = function () {
                this.Grafico?.destroy();
                this.GraficoTexto?.destroy();
            }

            this.Dibujar = function () {
                if (this.Grafico != null)
                    this.Eliminar();

                this.Grafico = new Konva.Line({
                    points: [this.PuntoInicial.Posicion.x, this.PuntoInicial.Posicion.y, this.PuntoFinal.Posicion.x, this.PuntoFinal.Posicion.y],
                    stroke: 'blue',
                    strokeWidth: 2
                });

                const dx = this.PuntoFinal.Posicion.x - this.PuntoInicial.Posicion.x;
                const dy = this.PuntoFinal.Posicion.y - this.PuntoInicial.Posicion.y;
                const distanciaPixeles = Math.sqrt(dx * dx + dy * dy);
                const distanciaMetros = distanciaPixeles * escala;

                this.GraficoTexto = new Konva.Text({
                    x: (this.PuntoInicial.Posicion.x + this.PuntoFinal.Posicion.x) / 2,
                    y: (this.PuntoInicial.Posicion.y + this.PuntoFinal.Posicion.y) / 2,
                    text: `${distanciaMetros.toFixed(2)}m`,
                    fontSize: 16,
                    fill: 'black',
                    padding: 4,
                    background: 'white'
                });

                layer.add(this.Grafico);
                layer.add(this.GraficoTexto);
            }
        }

        function Punto() {
            this.Tipo = enumTipoGrafico.Punto;
            this.Grafico = null;
            this.lstRelacionado = [];
            this.Arrastrable = false;

            this.Posicion = { x: null, y: null };

            this.Eliminar = function () {
                this.Grafico.destroy();

                this.lstRelacionado.forEach(function (item) {
                    item.Eliminar();
                });
            }

            this.Dibujar = function () {
                if (this.Grafico != null)
                    this.Eliminar();

                this.Grafico = new Konva.Circle({
                    x: this.Posicion.x,
                    y: this.Posicion.y,
                    radius: 5,
                    fill: 'red',
                    draggable: false
                });
                this.Grafico.on('mousedown', function () {
                    //Lienzo.PuntoActual = this;
                });

                layer.add(this.Grafico);

                this.lstRelacionado.forEach(function (item) {
                    item.Dibujar();
                });
            }
        }

        let layer;
        const escala = parseFloat($('#escalaInput').val());
        $(document).ready(function () {
            let stage = new Konva.Stage({
                container: 'container',
                width: 1200,
                height: 800
            });

            Lienzo.Stage = stage;

            //Instanciar las capas en el escenario
            layer = new Konva.Layer();
            stage.add(layer);

            //Variables booleanas
            let moviendo = false;
            let dibujando = false;
            var dibujandoLinea = false;

            const botonesIgnorados = ['crearPatioBtn', 'guardarBtn', 'selectPatio'];

            //Boton que permite la creacion del patio
            $('#crearPatioBtn').on('click', function () {
                dibujando = true;
                dibujandoLinea = false;
                layer.destroyChildren();
                layer.draw();
                $('#guardarBtn').prop('disabled', false);
            });

            //Evento que permite el zoom al girar la rueda del raton
            stage.on('wheel', (e) => {
                e.evt.preventDefault();
                const escalaAnterior = stage.scaleX();
                const cursor = stage.getPointerPosition();

                const escalarPor = 1.01;
                const direccion = e.evt.deltaY > 0 ? 1 : -1;
                const nuevaEscala = direccion > 0 ? escalaAnterior / escalarPor : escalaAnterior * escalarPor;

                stage.scale({ x: nuevaEscala, y: nuevaEscala });

                const mousePointTo = {
                    x: (cursor.x - stage.x()) / escalaAnterior,
                    y: (cursor.y - stage.y()) / escalaAnterior
                };
                stage.position({
                    x: cursor.x - mousePointTo.x * nuevaEscala,
                    y: cursor.y - mousePointTo.y * nuevaEscala
                });
                stage.batchDraw();
            });

            //Evento que permite dibujar si se da clic
            stage.on('mousedown', function (e) {
                if (!dibujando) return;
                console.log(e);
                const targetTag = e.target.getType();
                const htmlTarget = e.evt.target;

                if (botonesIgnorados.includes(htmlTarget.id)) return;

                const pos = stage.getPointerPosition();
                if (pos.x < 0 || pos.y < 0 || pos.x > stage.width() || pos.y > stage.height()) {
                    console.log('Clic fuera del stage');
                    return;
                }
                
                if (e.evt.button == 2) {
                    Lienzo.HabilitarArrastrable(true);
                    return;
                }

                const transform = stage.getAbsoluteTransform().copy();
                transform.invert();
                const posicion = transform.point(stage.getPointerPosition());

                Lienzo.AgregarPunto(posicion.x, posicion.y);
                if (Lienzo.lstPunto.length == 0)
                    Lienzo.AgregarPunto(posicion.x, posicion.y);
                dibujandoLinea = true;
            });

            //Acciones que se realizan al arrastrar el mouse
            stage.on('mousemove', function (e) {
                const transform = stage.getAbsoluteTransform().copy();
                transform.invert();
                const pos = transform.point(stage.getPointerPosition());


                if (dibujandoLinea && Lienzo.PuntoActual != null) {
                    Lienzo.PuntoActual.Posicion.x = pos.x;
                    Lienzo.PuntoActual.Posicion.y = pos.y;
                    Lienzo.PuntoActual.Dibujar();
                }
            });

            //Acciones que se realizan al dejar de hacer un clic sostenido
            stage.on('mouseup', function (e) {
                if (e.evt.button === 2) {
                    Lienzo.HabilitarArrastrable(false);
                }
            });

            //Instrucciones al dar click en el boton guardar
            $('#guardarBtn').on('click', function (e) {
                Lienzo.Cerrar();

                //Se guarda el nombre del input con el id nombreInput
                //const nombre = $('#nombreInput').val();

                //Arreglo de vertices que guarda el orden en el que fueron creados los puntos al recorrer
                //el array puntos con un for
                //const vertices = [];
                //for (let i = 0; i < puntos.length; i += 2) {
                //    vertices.push({ x: puntos[i].x, y: puntos[i].y, orden: vertices.length });
                //}

                ////Condicion que envia una alerta si alguno de los campos no se ha completado
                //if (!nombre || !escala || vertices.length === 0) {
                //    alert("Por favor, completa todos los campos y dibuja el patio antes de guardar.");
                //    return;
                //}

                ////Metodo POST usando jquery y ajax para comunicar con la BD
                //$.ajax({
                //    url: '/Patio/GuardarPatio',
                //    method: 'POST',
                //    data: JSON.stringify({
                //        nombre: nombre,
                //        escala: escala,
                //        vertices: vertices
                //    }),
                //    contentType: 'application/json',
                //    success: function (res) {
                //        alert("Guardado correctamente");
                //        dibujando = false;
                //        $('#guardarBtn').prop('disabled', true);
                //    }
                //});
            });

            //Metodo get que obtiene desde un JSON los datos desde la BD
            $.getJSON('/Patio/ListarPatios', function (data) {
                data.forEach(p => {
                    $('#selectPatio').append(`<option value="${p.Id}">${p.Nombre}</option>`);
                });
            });

            //Lista desplegable que muestra los patios ya registrados en DB
            $(`#selectPatio`).on('change', function () {
                const id = $(this).val();

                layer.destroyChildren();
                layer.draw();

                if (!id) return;
                //Metodo que obtiene los vertices de la figura y el orden mediante un JSON
                $.getJSON('/Patio/ObtenerPatioId', { id: id }, function (p) {
                    if (!p || !p.Vertices) return;

                    let puntos = [];
                    p.Vertices.forEach(v => {
                        puntos.push(v.X, v.Y);
                    });

                    //Se dibuja una figura en la capa segun el orden en el que se obtienen los vertices
                    let figura = new Konva.Line({
                        points: puntos,
                        stroke: 'black',
                        strokeWidth: 2,
                        closed: true
                    });

                    layer.add(figura);
                    layer.draw();
                });
            });
        });

    </script>
</body>
</html>

